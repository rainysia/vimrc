x = input("x:") 获取用户输入
2**3 = pow(2,3) 幂运算符**,乘方
round           四舍五入最接近的整数。
abs             绝对值
1//2            整除
1.0/2           浮点运算
19000000000L    L就是长整数
0xAF            十六进制
010             八进制
import 来导入模块
    import math
    math.floor(32.9) 会取整 =32.0
    要输出为整数
    int(math.floor(32.9)) 输出32,自动向下取整,所以可以直接int(32.9)
    要输出向上的整数，ceil
    math.ceil(32.9) 输出33, 32.0 =32 32.1=33

from模块import函数来指定。就不要在每次调用函数的时候都写模块名字
    sqrt是math里面计算一个数的平方根
    from math import sqrt
    sqrt(9)   输出3.0
    也可以用变量来引用函数foo=math.sqrt
        foo(4) = 2.0

sqrt(-1) 会输出nan/NAN 意思就是not a number 非数值
要处理负数的平方根（负数的平方根是虚数),需要用cmath(complex math,复数)模块
    import cmath
    cmath.sqrt(-1) 输出1j  j/J就是虚数,不使用from cmath import sqrt是怕命名冲突污染
        虚数相乘为-1
        >>>(1+3j)* (8+4j)
        8+4j+24j-12 = -4+28j

python IDE /idle
#apt-get install idle-python2.7

raw_input("Press <enter>") 来提供交互,
    与input不同，input会假设用户输入的都是合法的python表达式，而raw_input会把所有的输入当作原始数据(raw data)
    所有如果也是获取用户输入,如果是数字,需要进行转换.int(raw_input(''))

str函数， 把值转换为合理形式的字符串, str实际是一种类型,类似int/long，repr是函数。
repr函数，创建一个字符串以合法的python表达式的形式来表示值
    >>>print repr("Hello, world!")
    'Hello, world!'
    >>>print repr(10000L)
    10000L
    >>>print str("Hello, world!")
    Hello, world!
    >>>print str(10000L)
    10000
    repr也可以作为`x` 反引号的实现。
    >>>temp = 42
    >>>print "The temperature is " + `temp` 就不会报错,python3不再使用反引号，所以应该用repr


长字符串用'''string'''来包围,或者"""string""" 里面可以随意用单双引号。
如果一行的最后一个字符是反斜杠\ 换行符本身就转义而被忽略掉

原始字符串
    为了解决>>>path = "C:\nowhere"
            >>>path
            'C:\nowhere'
            >>>print path
            C:
            owhere
    对于短的，可以再转义一次
            >>print "c:\\nowhere"
            c:\nowhere
    对于长的，加上r表示原始字符串,原始字符串的最后一个字符不能是反斜线，除非转义,因为不知道是否应该结束字符串,如果非要原始字符串以一个反斜杠结尾，把这个反斜线作为一个字符串处理
        >>>print r'Let\'s go!'
        Let\'s go!
        >>>print r'C:\Program Files\foo\bar' '\\'
        C:\Program Files\foo\bar\

Unicode字符串,在python3.0，所有字符串都是unicode字符串
    u"hello, world1"

数据结构

    sequence 序列,python有6种序列,包括列表，元组，字符串，Unicode字符串，buffer对象，xrange对象
        列表可以修改，元组不能修改
    python中还有一种名叫容器container的数据结构。 容器就是包含其他对象的任意对象。
    序列（例如和元组）和映射（例如字典） 是两类主要的容器。 序列中的每个元素都有自己的编号，而映射中的每个元素则右一个名字（键）。集合set是既不是序列也不是映射的容器类型。

    所有序列都可以进行某些特定操作,索引indexing,分片slicing,加adding，乘multiplying
    以及检查某个元素是否属于序列的成员（成员资格）。除此之外，python还有计算序列长度，找出最大元素，最小元素的内建函数
    迭代iteration，对序列进行迭代的意思，就是依次对序列中的每个元素重复执行某些操作。
    字符串就是一个由字符组成的序列。索引0指向第一个元素

    分片slicing.可以指定步长step length,步长不能为0
        >>>numbers = [1,2,3,4,5,6,7,8,9,10]
        >>>numbers[0:10:2]  #[1,3,5,7,9]
        >>>numbers[::3]     #[1,4,7,10]
        >>>numbers[8:3:-1]  #[9,8,7,6,5]

    空列表，[]
    None python内建值，表示没有在里面放置任何元素
    初始化一个长度10的列表
        >>>sequence = [None] * 10
        >>>sequence
        [None,None,None,None,None,None,None,None,None,None]

    成员资格用in运算符,返回True/False
    内建函数len 返回序列包含元素的数量
    内建函数min/max返回序列中最大/最小的元素

    list函数，实现字符串可以像列表一样被修改,list也适用于所有类型的序列。
        >>>list('Hello')
        ['H','e','l','l','o']
        可以用''.join(somelist)来把列表转换为字符串

    分片赋值,可以赋值不等长的序列
        >>>name=list('perl')
        >>>name[2:]=list('ar')
        >>>name
        ['p','e','a','r']
    列表方法
        append/count/extend/index/insert/pop/remove/reverse/sort
        pop是唯一一个既能修改列表又返回元素值(除了None)的列表方法

    元组，不可变的序列
    用逗号分割值，就自动创建了元组,元组大部分是通过圆括号括起来的。可以用没有那个的两个圆括号表示空元组
        >>>42  #42
        >>>42, #(42,)
        >>>(42,) #(42,)
        >>>3*(40+2)  #126
        >>>3*(40+2,)  #(42,42,42)
    tuple函数,以一个序列作为参数并把它转换为元组。 如果参数是元组就原样返回
        >>>tuple([1,2,3]) #(1,2,3)
        >>>tuple('abc') #('a','b','c')
        >>>typle(1,2,3) #(1,2,3)
    元组操作
        >>>x=1,2,3 #x = (1,2,3)
        >>>x[1] #2
        >>>x[0:2] (1,2)
    cmp函数cmp(x,y) 比较两个值。1,0,-1


    格式化字符串，字符串格式化操作符%, %s是转换说明符conversion specifier, 标记了需要插入转换值的位置，s表示值会被格式化成字符串，如果不是字符串，会用str将其转换为字符串
        如果格式化字符串有百分号。就用%%，这样python就不会将百分号误认为是转换说明符了。
        >>>format = "Hello, %s. %s enough for ya?"
        >>>values = ('world','Hot')
        >>>print format %s vlaues
        Hello, world. Hot enough for ya?
    格式化浮点数,f和精度 如%.3f是小数点后保留3位。 因为格式化转换说明符总是以表示类型的字符结束，所以精度在类型字符的前面
        >>>format = "Pi with three 10 decimals: %.10f"
        >>>from math import pi
        >>>print format % pi
        Pi with 10 decimals:3.1415926536

    string模块提供另外一种格式化方法,模板字符串,substitute模板方法会用传递进来的关键字参数foo替换掉字符串中的$foo
        >>>from string import Template
        >>>s = Template('$x,glorious $x!')
        >>>s.substitute(x='slurm')
        'slurm. glorious slurm!'
    如果替换字段是单词的一部分，参数名需要用括号括起来 ${x}
    可以使用$$插入美元符号,除了关键字参数以外，还可以使用字典变量提供值/名称对
        >>>s=Template('A $thing must never $action.')
        >>>d={}
        >>>d['thing'] = 'gentleman'
        >>>d['action'] = 'show his socks'
        >>>s.substitute(d)
        'A gentleman must never show his socks.'
    如果格式化的右边(右操作数)是元组的话,则其中的每一个元素都会被单独格式化.每个值都需要一个对应的转换说明符
    如果需要转换的元组作为转换表达式的一部分存在,那么必须将它用圆括号括起来.
        >>>'%s plus $s equals $s' % (1,1,2)
        '1 plus 1 equals 2'
    字符串转换类型
        %标记转换说明符的开始
        转换标志(可选)-表示左对齐,+表示在转换值之前要加上正负号,""空白字符表示正数之前保留空格,0表示转换值若位数不够则用0填充
        最小字段宽度(可选),转换后的字符串至少应该具有该值指定的宽度.如果是*,则宽度会从元组中读取 
        点. 后跟精度值(可选),如果转换的是实数,精度值会表示在小数点后的位数.  如果转换的是字符串,那么该数字就表示最大字段宽度,如果是*,精度会从元组中读书
            d,i     带符号的十进制整数
            o       不带符号的八进制
            u       不带符号的十进制
            x       不带符号的十六进制 小写
            X       不带符号的十六进制 大写
            e       科学计数法表示的浮点数 小写
            E       科学计数法表示的浮点数 大写
            f,F     浮点数
            g       如果指数大于-4或者小于精度值则和e相同.其他情况和f相同
            G       如果指数大于-4或者小于精度值则和E相同.其他情况和F相同
            C       单字符 接受整数或者单字符字符串
            r       字符串  使用repr转换任意python对象
            s       字符串 使用str转换任意python对象
        注意,比如%10f % pi 会取
        3.141593,因为不带精度的时候会默认为6的精度.整数位不足会补空值.所以在字段宽度和精度前
            >>> from math import  pi
            >>> '%010f' % pi
            '003.141593'
            >>> '-%10f' % pi
            '-  3.141593'
            >>> '%-10f' % pi
            '3.141593  '
            >>> '%+10f' % pi
            ' +3.141593'
            >>> '%10f' % pi
            '  3.141593'

    字符串方法. 来源于string模块.
        >>>import string
        >>>string.字符串方法

        find方法在一个较长的字符串中查找子串.返回子串所在位置的最左端索引. 没找到返回-1
        find('子串',[起始点],[结束点]) []是可选的参数 
        join是split方法的逆方法,用来连接序列中的元素(元素必须是字符串)
            >>> a = ['1','2','3']
            >>> b = '+'
            >>> b.join(a)
            '1+2+3'
        lower返回字符串的小写版, 相反的是title方法,会把所有单词的首字母大写. 但是可能不自然, 用string模块的capwords函数.
        string.capitalize 返回首字母大写的字符串的副本.
        string.center(width[, fillchar])  返回一个长度为max(len(string), width)且string的副本居中的字符串,两侧使用fillchar填充
        string.count(sub[, start[, end]]) 计算子字符串出现的次数,可以限定搜索范围
        string.decode([encoding[, errors]])
        string.encode([encoding[, errors]])
        string.endswith(suffix[, start[,end]]) 检查string是否以suffix结尾
        string.expandtabs([tabsize]) 返回字符串副本,其中tab字符会以默认8个空格扩展,可以选tab以几个空格
        string.find(sub[, start[,end]]) 返回子字符串的第一个索引,不存在返回-1
        string.index(sub[, start[,end]])返回子字符串的第一个索引,找不到索引的时候引发valueError异常
        string.isalnum()    检查字符串是否由字母/数字字符组成
        string.isalpha()    检查是否由字母字符组成
        string.isdigit()    检查是否由数字组成
        string.islower()    检查是否都为小写
        string.istitle()    检查是否不基于实例的字母后面的基于实例的字符都是答谢,且其他的基于实例的字符都是小写
        string.isspace()    检查字符串是否由空格组成
        string.isupper()    检查基于实例的字符都是答谢
        string.join(sequence)   返回其中sequence的字符串元素已用string连接的字符串
        string.ljust(width[, fillchar]) 返回一个长度为max且其中string的副本左对齐的字符串,右侧使用fillchar默认空字符填充
        string.lower()  返回一个字符串的副本,所有基于实例的字符都是小写
        string.lstrip([chars])  返回去除开始处所有char的字符串副本,默认char为空白字符,比如空格,tab,换行符
        string.partition(sep)   在字符串中搜索sep并返回(head,sep,tail)
        string.replace(old, new[, max]) 替换
        string.rfind(sub[, start[, end]]) 返回找到的最后一个索引,不存在返回-1
        string.rindex(sub[,start[,end]])  返回被找到的最后一个索引,不存在返回valueerror
        string.rjust(width[,fillchar])  返回右对齐,左侧用fillchar填充的字符串
        string.rpartition(sep)  同partition,但是从右侧开始查找
        string.rstrip([chars])  同strip,不过是从字符串结束处去除.
        string.rsplit([sep[, maxsplit]]) 同split,但是在使用maxsplit的时候是从右向左计数
        string.split([sep[, maxsplit]]) 返回字符串中所有单词的列表,使用sep作为分隔符(如没指定则以空格切分,可使用maxsplit来指定最大切分数)
            a = 'a hello wolrd a, you\'are so beautiful'
            >>> a.split()
            ['a', 'hello', 'wolrd', 'a,', "you'are", 'so', 'beautiful']
            >>> a.split(',')
            ['a hello wolrd a', " you'are so beautiful"]
        string.splitlines([keepends]) 返回所有string中所有行的列表,可选择是否包括换行符,如提供keepends则包括
            >>> import string
            >>> a = '123132asdfew'
            >>> print a
            123132asdfew
            >>> a.splitlines()
            ['123132asdfew']
        string.startswidth(prefix[,start[,end]]) 检查string是否以prefix开头, 可以用开始,结束来指定匹配范围
        string.strip([chars])   默认为空格的chars都从开头和结尾去除(不包括内部).默认为所有空白字符,包括空格.tab.换行符
        string.swapcase()   交换大小写
        string.title()  返回字符串的副本,单词以大写字母开头, 包括i'm => I'M, 可以用capwords函数来处理i'm => I'm
        string.translate(table[, deletechars])  返回字符串的副本,其中所有字符都使用table替换, 可选择删除出现在deletechars中的所有字符
            替换换行符,等,优势在于可以同时进行多个替换.有时候比replace效率高.
            转换前需要一个转换表table, 可以用maketrans函数来, maketrans接受两个参数, 两个等长的字符串,来表示第一个字符串中的每个字符都要用第二个字符串中相同位置的字符替换.
                >>>from string import maketrans
                >>>table = maketrans('cs', 'kz')
            转换表是包含替换ASCII字符集中256个字符的替换字母的字符串
                >>>table = maketrans('cs', 'kz')
                >>>len(table)
                256
                >>>table[97:123]
                'abkdefghijklmnopqrztuvwxyz'
                >>>maketrans('', '')[97,123]
                'abcdefghijklmnopqrstuvwxyz'
        string.upper()  返回字符串的副本,其中所有基于实例的字符都是大写的
        string.zfill(width) 在string的左侧以0填充width个字符


    字典,mapping,键可以是数字,字符串,元组., 字典是python中唯一内建的映射类型.
        字典的key是唯一的,如果重复,会以最后一个key的value为value
        创建字典 a = {'alice':'234','bb':'23','cc':'32'}
            >>> a = {'a':'23','b':'23','c':'321321','a':'32'}
            >>> a
            {'a': '32', 'c': '321321', 'b': '23'}
            >>> a['a']
            '32'
            >>> a['a']='hello'
            >>> a
            {'a': 'hello', 'c': '321321', 'b': '23'}
            >>> 'c' in a
            True
            >>> del a['a']
            >>> a
            {'c': '321321', 'b': '23'}
        key键类型是任意的不可变类型,比如浮点,实型,字符串,元组等.
        键如果不存在,当赋值的时候会自动创建
        成员资格, k in d(d为字典)查找的是键,不是值,表达式v in l(l为列表l)则是用来查找值的,而不是索引
        在字典中检查键的成员资格比在列表中检查值的成员资格更高效,数据结构规模越大,两者效率差距越明显.
            >>> x=[]            #空列表
            >>> x[42]='foobar'
            Traceback (most recent call last):
              File "<pyshell#109>", line 1, in <module>
                x[42]='foobar'
            IndexError: list assignment index out of range
                #可以用 [NONE]*43来初始化列表x
                    >>> x=[None]*43
                    >>> x
                    [None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None]
                    >>> x[42]='foobar'
                    >>> x
                    [None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, 'foobar']
            >>> x={}            #空字典
            >>> x[42]='foobar'
            >>> x
            {42: 'foobar'}

    字典方法
        aDict.clear()   移除aDict所有的项
        aDict.copy()    返回aDict的副本
            copy是浅复制shallow copy,内存中实际是一份,可以使用深复制deep copy,
                >>> from copy import deepcopy
                >>> d = {}
                >>> d['name'] = ['tommyxia','rainysia']
                >>> c = d.copy()
                >>> dc = deepcopy(d)
                >>> d['name'].append('yuliang.xia')
                >>> c
                {'name': ['tommyxia', 'rainysia', 'yuliang.xia']}
                >>> dc
                {'name': ['tommyxia', 'rainysia']}
                >>> d.clear()
                >>> c
                {'name': ['tommyxia', 'rainysia', 'yuliang.xia']}
                >>> dc
                {'name': ['tommyxia', 'rainysia']}
                >>> d
                {}
        aDict.fromkeys(seq[,val])   返回从seq中获得的键和被设置为val的值的字典,使用给定的键建立新的字典.每个键都对应一个默认值None
            >>> {}.fromkeys(['name','age'])
            {'age': None, 'name': None}
            >>> dict.fromkeys(['name','age','degree'])
            {'age': None, 'name': None, 'degree': None}
            >>> {}.fromkeys(['name','age'], '(hahah)')
            {'age': '(hahah)', 'name': '(hahah)'}
            dict是所有字典的类型.所以可以直接在dict上调用fromkeys函数
        aDict.get(key[,default])    如果aDict[key]存在,将其返回;否则返回给定的默认值(默认为None)
            >>> d = {}
            >>> d['a']
            Traceback (most recent call last):
              File "<pyshell#169>", line 1, in <module>
                d['a']
            KeyError: 'a'
            >>> d.get('name')
            >>> print d.get('name')
            None
            >>> print d.get('name','N/A')
            N/A
        aDict.has_key(key)          检查aDict是否右给定键key,python3.x不存在
        aDict.items()               返回表示aDict项的(键,值)对列表
        aDict.iteritems()           返回表示aDict项的(键,值)对相同的(键,值)对中返回一个可迭代对象
            >>> d = {'title':'123','name':'tommy','spam':0}
            >>> d
            {'spam': 0, 'name': 'tommy', 'title': '123'}
            >>> d.items()
            [('spam', 0), ('name', 'tommy'), ('title', '123')]
            >>> it = d.iteritems()
            >>> it
            <dictionary-itemiterator object at 0x1333470>
            >>> list(it)
            [('spam', 0), ('name', 'tommy'), ('title', '123')]
        aDict.iteerkeys()           从aDict的键中返回一个可迭代对象
        aDict.itervalues()          从aDict的值中返回一个可迭代对象
        aDict.keys()                返回aDict的键列表
        aDict.pop(key[,d])          移除并且返回给定键key或给定的默认值d的值
        aDict.popitem()             从aDict中移除随机项,并将其作为(键,值)对返回
        aDict.setdefault(key[,default]) 如果aDict[key]存在则将其返回;否则返回给定的默认值(默认为none),并将aDict[key]的值绑定给该默认值(字典中不含有给定键的情况下设定相应的键值)
            >>> d={}
            >>> d.setdefault('name','N.A')
            'N.A'
            >>> d
            {'name': 'N.A'}
            >>> d['name']='tommy'
            >>> d
            {'name': 'tommy'}
            >>> d.setdefault('name','N/A')
            'tommy'
            >>> d
            {'name': 'tommy'}
        aDict.update(other)         将other中的每一项都加入到aDict中,可能会重写已存在的项
        aDict.values()              返回aDict中值的列表(可能包括相同的)
            >>> d = {'1':1,'2':1,'3':3,'4':'ab','5':'21'}
            >>> d
            {'1': 1, '3': 3, '2': 1, '5': '21', '4': 'ab'}
            >>> d.values()
            [1, 3, 1, '21', 'ab']


    语句
        导入的时候,同命名的函数,可以用别名
            from module1 import open as open1
            from module2 import open as open2
            或者
            import module1
            import module2
            module1.open(...)
            module2.open(...)
        序列解包, 将多个值的序列解开,然后放到变量的序列中.
            >>> values = 1,2,3
            >>> values
            (1, 2, 3)
            >>> x,y,z=values
            >>> y
            2
            如果获取/删除字典中任意的键值对,可以用popitem方法.将键值对作为元组返回.然后会复制给两个变量
                >>> scoudrel = {'name':'tommyx','title':'se'}
                >>> key,value=scoudrel.popitem()    #popitem是随机的
                >>> key
                'name'
                >>> value
                'tommyx'
        链式赋值chained assignment
            x = y = somefunction() 等于
            x=somefunction()
            x=y
            可能不等于
            x=somefunction()
            y=somefunction()

        布尔值false 包括
            Flase None 0 "" ()  []              {}
                                空列表/空元组  空字典
        bool函数可以转换其他值为布尔值
            bool([])==bool("")==Flase 但是[]!="" 因为类型不一样

        同一性运算符is, 判断同一性而不是相等性,x,y绑定在同一个列表中,z绑定在另一个具有相同数值和顺序 列表中.它们值那个相等,但是却不是同一个对象
            >>> x=y=[1,2,3]
            >>> z=[1,2,3]
            >>> x==y
            True
            >>> x==z
            True
            >>> x is y
            True
            >>> x is z
            False
        使用==运算符来判定两个对象是否相等, 使用is来判断两者是否等同(同一个对象)
        字符串可以按照字母顺序进行比较
            >>>'alpha' < 'beta'
            True
        三元
            >>> 1 if True else Flase
            1
        断言, assert 条件,后可跟解释性字符串
            >>> age = -1
            >>> assert 0<age<130, "The age must be realistic"
            Traceback (most recent call last):
              File "<pyshell#229>", line 1, in <module>
                assert 0<age<130, "The age must be realistic"
            AssertionError: The age must be realistic
        For循环遍历字典(序列解包)
            >>> d={'x':1,'y':2,'z':'we'}
            >>> for key,value in d.items():
                print key, '==', value

            y == 2
            x == 1
            z == we
            >>> d.items()
            [('y', 2), ('x', 1), ('z', 'we')]
        并行迭代.
            >>> names = ['tom','kevin','susan']
            >>> ages =[28,33,44]
            >>> for i in range(len(names)):
                print names[i], 'is', ages[i], 'years old'

                
            tom is 28 years old
            kevin is 33 years old
            susan is 44 years old

        zip函数压缩后返回一个元组的列表.
            >>> zip(names,ages)
            [('tom', 28), ('kevin', 33), ('susan', 44)]
            >>> for name,age in zip(names,ages):
                print name, 'is', age, 'years old'

                
            tom is 28 years old
            kevin is 33 years old
            susan is 44 years old
        zip函数也可以作用任意多的序列,来处理不等长的序列.当最短的序列"用完"的时候会停止循环.
        这里xrange是一次创建一个数,而range会一次创建整个序列.所以序列越大,xrange越高效,下面代码里xrange只计算了5次,每次1个数.
            >>> zip(range(5), xrange(100000))
            [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]

        按索引迭代,也可以用enumerate函数
            >>> index = 0
            >>> for string in strings:
                if 'xxx' in string:
                    strings[index] = '[censored]'
                index +=1

            for index,string in enumerate(strings):
                ...
        翻转/排序迭代 reversed/sorted

        wile True/break
            while True:
                word = raw_input('pls enter a word: ')
                if not word: break
                print 'The word was ' + word

        for else子句, 仅在没有调用break时执行.
        列表推导式list comprehension
            >>>[x*x for x in  range(10)]
            [0,1,4,9,16,25,36,49,64,81]
            >>>[x*x for x in  range(10) if x % 3 == 0]
            [0,9,36,81]
            >>>[(x,y) for x in range(3) for y in range(3)]
            [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2), (2,0), (2,1), (2,2)]
            等同于
            result = []
            for x in range(3):
                for y in range(3):
                    result.append((x,y))
        pass是为了解决python中空代码块非法.什么都不做
        del语句删除的是名称,而不是删除的值,值是由Python解释器的内存回收的.
        exec/eval可以用in scope来实现作用域,exec是执行一个语句,eval是用于求值的类似exec的内置函数.
            >>> from math import sqrt
            >>> scope = {}
            >>> exec 'sqrt=1' in scope
            >>> sqrt(4)
            2.0
            >>> scope['sqrt']
            1
        eval语句可以提供两个命名空间,一个全局的,必须是字典.局部的可是是任意形式的映射.
        chr(n)函数, 传入序号n时,返回n所代表的包含一个字符的字符串,0<=n<=256
            >>> chr(0)
            '\x00'
            >>> chr(98)
            'b'
        ord(c) 返回单字符字符串的int值
            >>> ord('a')
            97
            >>> 

    Abstract抽象
        2.x callable函数,判断函数是否可以调用
        3.x 弃用callable, 使用hasattr(func, __call__)替代
            >>> import math
            >>> x = 1
            >>> y = math.sqrt
            >>> callable(x)
            False
            >>> callable(y)
            True
    
    def 定义函数, 函数如果没有返回值,默认会返回None
    在函数内部开头写下字符串,这个字符串会作为函数的一部分进行存储,称为文档字符串
    文档字符串可以使用 函数名.__doc__来进行访问. 注意不是注释, 也不需要传参
    内建的help(函数名) 可以得到函数,包括文档字符串的信息.

    函数可以使用关键字参数来传入指定的实参
        >>>def store(patient='test1', name='test2'):
                return patient,name
        如果既有位置参数又有关键字参数, 应该把位置参数放到前面. 避免未定义.

    收集参数. 指定一个参数在前面加上星号,
    就可以传入多个位置参数,并且存在一个元组里面,如果不提供任何供收集的元素,就会是空元组
        def print_params(*params):
            print params

        print_params(1,2,3)     #(1,2,3)
        print_params('Testing') #('Testing',)

        def print_params_2(title, *params):
            print title
            print params

        print_params_2('CEO','Tom','Nico','Deb')    #CEO \n ('Tom', 'Nico', 'Deb')

        print_params_2('CEO')       #CEO \n ()
    注意不能使用关键字参数
        >>>print_params_2(test='CEO', 'Tom')
        File "collect.py", line 17                                                                      
        print_params_2(test='CEO', 'Tom')                                                             
        SyntaxError: non-keyword arg after keyword arg  
    可以使用两个星号**params来收集,这样返回的就是字典而不是元组
        def print_p(x,y,z=3, *pops, **keypars):
            print x,y,z
            print pops
            print keypars
        >>>print_p(1,2,3,4,5,67,a='12',b='hel',c=3)
        1 2 3
        (4, 5, 67)
        {'a': '12', 'c': 3, 'b': 'hel'}
        >>>print_p(1,2)
        1 2 3
        ()
        {}
    可以使用星号,两个星号在调用的时候传递更多的数据(元组/字典)
        >>> def add(x,y):
            return x+y

        >>> params=(1,2)
        >>> add(*params)
        3
        >>> def with_stars(**kwds):
            print kwds['name'],'is',kwds['age'],'years old'

        >>> def without_stars(kwds):
            print kwds['name'],'is',kwds['age'],'years old'

        >>> args = {'name':'tommy','age':'28'}
        >>> with_stars(**args)
        tommy is 28 years old
        >>> without_stars(args)
        tommy is 28 years old

        >> def story(**kwds):
            return 'Once upon a time , there was a  %(job)s called %(name)s.' % kwds

        >>> print story(job='king', name='tommy')
        Once upon a time , there was a  king called tommy.
        >>> print story(name='Tommy X', job='light knight')
        Once upon a time , there was a  light knight called Tommy X.
        >>> params={'job':'lanuage','name':'php'}
        >>> print story(**params)
        Once upon a time , there was a  lanuage called php.
        >>> del params['job']
        >>> params
        {'name': 'php'}
        >>> print story(job='amazing fast language', **params)
        Once upon a time , there was a  amazing fast language called php.
        >>> 

    globals函数获取全局变量值,vars返回全局变量的字典,locals返回局部变量的字典
        >>> x = 1
        >>> def change_global():
            global x
            x = x+2
            
        >>> change_global()
        >>> x
        3

    map(func, seq[, seq, ...])  对序列中的每个元素应用函数
    filter(func, seq)           返回其函数为真的元素的列表
        >>> def func(x):
            return x.isalnum()
        >>> seq=['tommy','x10','?3','**']
        >>> filter(func, seq)
        ['tommy', 'x10']
    reduce(func, seq [,initial])等同于func(func(seq[0], seq[1], seq[2],...))
    sum(seq)                    返回seq中所有元素的和
    apply(func[,args[, kwargs]])调用函数, 可以提供参数

Object 对象
    多态,polymorphism 意味着可以对不同类的对象使用同样的操作.
    封装,encapsulation,对外部世界隐藏对象的工作细节
    继承,inheritance,以通用的类为基础建立专门的类对象

    标准库random中包含choice函数,可以从序列中随机选出元素,然后给变量赋值
        >>> from random import choice
        >>> x = choice(['hello,wordl',[1,2,'e','e',4]])
        >>> x
        'hello,wordl'
        >>> x.count('e')
        1
        >>> x.count('l')
        3
        >>> x= choice(range(1000))
        >>> any numbers in the range of 1000.

    类, 默认新式类需要加载下面的内容.
        __metaclass__ = type #确定使用新式类

        class Person:
            def setName(self, name):
                self.name = name

            def geName(self):
                return self.name

            def greet(self):
                print "Hello, World! I'm %s ." % self.name

        >>> foo = Person()
        >>> bar = Person()
        >>> foo.setName('haha1')
        >>> bar.setName('haha2')
        >>> foo.greet()
        Hello,world! I'm haha1. 
        >>> bar.greet()
        Hello,world! I'm haha2. 
        >>> foo.name
        'haha1'
        >>> bar.name
        'haha2'
Python的类的方法和普通的函数有一个很明显的区别，在类的方法必须有个额外的第一个参数 (self )，但在调用这个方法的时候不必为这个参数赋值 （显胜于隐 的引发）。Python的类的方法的这个特别的参数指代的是对象本身，而按照Python的惯例，它用self来表示。（当然我们也可以用其他任何名称来代替，只是规范和标准在那建议我们一致使用self）
为何Python给self赋值而你不必给self赋值？
例子说明：创建了一个类MyClass，实例化MyClass得到了MyObject这个对象，然后调用这个对象的方法MyObject.method(arg1,arg2) ，这个过程中，Python会自动转为Myclass.mehod(MyObject,arg1,arg2)
这就是Python的self的原理了。即使你的类的方法不需要任何参数，但还是得给这个方法定义一个self参数，虽然我们在实例化调用的时候不用理会这个参数不用给它赋值。

    python并不直接支持私有方式. 不过可以在方法/变量前加上__ 双下划线. 实际上也可以通过 "_类名__方法名"来直接从外部访问
        >>> class secretive:
            def __inaccessible(self):
                print "Bet you can't see..."
            def accessible(self):
                print "You can see:"
                self.__inaccessible()

        >>> foo = secretive()
        >>> foo.accessible()
        You can see:
        Bet you can't see...
        >>> foo.__inaccessible()

        Traceback (most recent call last):
          File "<pyshell#31>", line 1, in <module>
            foo.__inaccessible()
        AttributeError: secretive instance has no attribute '__inaccessible'
        >>> foo._secretive__inaccessible
        <bound method secretive.__inaccessible of <__main__.secretive instance at 0x17baf38>>
    单下划线,都不会被带星号的import语言导入(from module import *)

    类的命名空间 
        下面两个语句几乎等价
        def foo(x): return x*x
        foo = lambda x:x*x
        在类里面, 可以直接定义一个可供所有成员(实例)访问的变量.用init来初始化所有实例.
            >>> class MC:
                members = 0
                def init(self):
                    MC.members+=1

                
            >>> m1=MC()
            >>> m1.init()
            >>> MC.members
            1
            >>> m2=MC()
            >>> m2.init()
            >>> MC.members
            2

    对类进行修改,就叫子类对超类的扩展
        >>> class F:
            def init(self):
                self.blocked=[]
            def filter(self, sequence):
                return [x for x in sequence if x not in self.blocked]
            
        >>> class sf(F):
            def init(self):
                self.blocked=['SPAM']
                
        >>> f=F()
        >>> f.init()
        >>> f.filter([1,2,3])
        [1, 2, 3]
        >>> s=sf()
        >>> s.init()
        >>> s.filter(['spam','spam','eee','haha','spam','SPAM'])
        ['spam', 'spam', 'eee', 'haha', 'spam']
    查看一个类是否是另外一个类的子类, 可以用内建的issubclass函数,issubclass(子类,超类)
        >>> issubclass(sf,F)
        True
    如果想要知道已知类的基类(们),可以用__bases__:
        >>> sf.__bases__
        (<class __main__.F at 0x17cdce8>,)
        >>> F.__bases__
        ()
    也可以用isinstance方法来检查一个对象是否是一个类的实例
        >>> s=sf()
        >>> isinstance(s, sf)
        True
        >>> isinstance(s,F)
        True
        >>> isinstance(s,str)
        False
    如果只想支持一个对象属于哪个类,可以使用__class__特性
        >>> s.__class__
        <class __main__.sf at 0x17cdd50>

    多重继承multiple
    inheritance,如果一个方法从多个超类继承(也就是多个相同名字的不同方法),就需要注意超类的顺序.先继承的类中的方法会重写后继承的类中的方法.(注意是前面的重写后面的)
        下例中子类TC不做任何事,它从自己的超类继承所有
        class Calculator:
            def calculate(self, expression):
                self.value = eval(expression)

        class Talker:
            def talk(self):
                print 'Hi, my value is', self.value

        class TalkingCalculator(Calculator, Talker):
            pass

        tc = TalkingCalculator()
        tc.calculate('1+20*20')
        tc.talk()

    使用hasattr(x,'__call__')来代替在python3.0弃用的callable,检测所需方法是否存在,
    getattr函数,允许提供默认值以便在特性(函数)不存在时调用, 对应的是setattr函数,可以用来设置对象的特性.
        >>> setattr(tc, 'name', 'Mr.Tom')
        >>> tc.name
        'Mr.Tom'
        >>>callable(getattr(tc,'talk', 'NNN'))
        True
        >>> hasattr(tc,'echo')
        False
    如果要查看对象内所有存储的值,可以用__dict__特性.
        >>> tc.__dict__
        {'name': 'Mr.Tom', 'value': 401}
    Type(object) 返回对象的类型.
    callable(object)
    getattr(object,name[,default])
    hasattr(object, name)
    isinstance(object, class)
    issubclass(A,B)
    random.choice(sequence)
    setattr(object, name, value)

异常
    python用异常对象(exception object)来表示异常情况,如果异常未被处理或捕捉,程序就用回溯(traceback,一种错误信息)终止执行
    为了引发异常,可以用一个exception的子类或者实例参数调用raise语句. 使用时,程序会自动创建类的实例
        >>> raise Exception
        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        Exception
        >>> raise Exception('Hello wrong!')
        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        Exception: Hello wrong!
    可以查看exceptions模块用dir函数来列出所有的模块内容
        >>>import exceptions
        >>>dir(Exceptions)
        ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', '...']
    所有异常都可以用在raise语句中
        >>>raise BaseException
          ...
    一些内建常用的异常
        Exception 所有异常的基类
        AttributeError 特性引用/赋值失败时引发
        IOError     试图打开不存在文件(包括其他情况)引发
        IndexError  在使用序列中不存在的索引时引发
        KeyError    在使用映射中不存在的键时引发
        NameError   在找不到名字(变量)时引发
        SyntaxError 在代码为错误形式时引发
        TypeError   在内建操作或者函数应用于错误类型的对象时引发
        ValueError  在内建操作或者函数应用于正确类型的对象,但是该对象使用不合适的值时引发
        ZeroDivisionError   在除法或者模除操作的第二个参数为0时引发
    可以自己自定义异常类,使用继承Exception
        class someCustomeException(Exception): pass
    捕捉异常
            try:
                x = input('Enter the first number: ')
                y = input('Enter the second number: ')
                print x/y
            except ZeroDivisionError:
                print "The second name can't be zero"
    如果没有捕捉到异常,就会被传播到调用的函数中,如果那里也没有捕获,这些异常最终会浮到程序的最顶层.也就是说可以捕捉到其他人的函数中所引发的异常.
    如果捕捉到了异常,但是又想重新引发它.(传递异常,不进行处理),可以用不带参数的raise
        class MuffledCalc:
            muffled = False
            def calc(self, expr):
                try:
                    return eval(expr)
                except ZeroDivisionError:
                    if  self.muffled:
                        print 'Division by zero is illegal!'
                    else:
                        raise

        ca = MuffledCalc()
        ca.calc('10/2')
#ca.calc('10/0')
        ca.muffled = True
        ca.calc('10/0')
    多个异常,可以多个调用,在上面的代码中继续加入excep TypeError: ......
    或者是用一个块来捕捉多个类型异常, 可以将它们作为元组列出
        try:
            ...
        except(ZeroDivisionError, TypeError, NameError):
            print 'xxx...'
    如果想要打印异常的内容.在except子句中访问异常对象本身,用e 
        python 2.x  except(ZeroDivisionError, TypeError), e:
                        print e
        python 3.x  except(ZeroDivisionError, TypeError) as e:
                        print e
    当没有异常引发的时候, 可以用else子句的break来退出, 也就是说,如果程序中有错误,就不断要求重新输入,直到没有错误
        while True:
            try:
                x = input('Enter the first number: ')
                y = input('Enter the second number: ')
                value = x/y
                print 'x/y is', value
            except Exception,e:
                print 'Invalid input: ',e
                print 'pls try agin!'
            else:
                break
    finally子句,用来在可能的异常后进行清理.和try子句联合
        x = None
        try:
            x = 1/0
        except NameError:
            print 'UNknown variable'
        else:
             print "That went well!"
        finally:
            print 'Cleaning UP'
            #可以在finally这里执行一些关闭文件/网络套接字, 非常有用


魔术方法/属性/迭代器
    魔术方法,在名称前后加两个下划线的.如果对象实现了这些方法中的某一个,那么这个方法将会在特殊的情况下(根据名字)被python调用
        __init__
    属性,以前的版本的python使用魔术方法来处理,现在通过property函数
    迭代器,使用魔术方法的__iter__来允许迭代器在for循环中使用

    构造方法
        class Foobar:
            def __init__(self):
                self.somevar = 42

    调用未绑定的超类构造方法(为了解决子类继承超类的方法,其中该方法中有超类的初始化的情况)
        class Bird:
            """docstring for Bird"""
            def __init__(self):
                self.hungry = True
            def eat(self):
                if  self.hungry:
                    print 'Aaaah...'
                    self.hungry = False
                else:
                    print 'No, Thanks!'

        b = Bird()
        b.eat()
        b.eat()

        class SongBird(Bird):
            def __init__(self):
                Bird.__init__(self)
                self.sound = 'Squawk!'
            def sing(self):
                print self.sound

        sb = SongBird()
        sb.sing()
    在调用一个实例的方法时,该方法的self参数会自动绑定到实例上(这称为绑定方法);但如果直接调用类的方法(比如Bird.__init__),那么就没有实例会被绑定.这样就可以自由地提供需要的self参数.这样的方法称为未绑定(unbound)方法.
    super函数,(python3.x中不带任何参数就可以调用),只支持在新式类中调用
    当前的类和对象可以作为super函数的参数使用,调用函数返回的对象的任何方法都是调用超类的方法,而不是当前类的方法.
    __metaclass__ = type 
    class Bird:
        def __init__(self):
            self.hungry = True
        def eat(self):
            if  self.hungry:
                print 'Aaaah....'
                self.hungry = False
            else:
                print 'No, thanks!'
    class SongBird(Bird):
        def __init__(self):
            super(SongBird, self).__init__()
            self.sound = 'Squawk'
        def sing(self):
            pritn self.sound

    其他的魔术方法
    __len__(self)   返回集合中所含项目的数量/序列的元素个数/隐射的键值对的数量
    __getitem__(self, key) 返回所给键对应的值./序列是0~n-1的整数(负数),/映射则是任何种类的键
    __setitem__(self, key, value)   设置
    __delitem__(self, key)  对一部分对象del语句时调用.同时必须删除和元素相关的键
    对上面的方法, 如果是一个序列,键是负整数,就要从末尾开始计数,x[-n] = x[len(x)-n],如果键不是一个合适的类型,如对序列用字母做key,会引发typeError异常.
        如果序列的索引是正常的类型,但是超出了范围,会引发一个IndexError异常

    访问器方法,是一个简单的方法,能够使用getHeight,setHeight来得到或者重绑定一些特性(可能是类的私有属性)
        class Rectangle:
            """docstring for Rectangle"""
            def __init__(self):
                self.width = 0
                self.height = 0
            def setSize(self, size):
                """docstring for setSize"""
                self.width, self.height = size
            def getSize(self):
                """docstring for getSize"""
                return self.width, self.height

        r = Rectangle()
        r.width = 10
        r.height = 15
        print r.getSize()
        r.setSize((150,100))
        print r.width
    这里把size由width和height组成了元组

    property函数, 这里创建了一个属性,其中访问器函数就被用作参数(先取值,再赋值), 这个属性被命名为size. 必须要是新式类.
    propery(fget, fset, fdel[,], doc[,]) 第三个参数(可选)是用于删除特性的方法,不需要参数, 第四个参数(可选)是一个文档字符串
        __metaclass__ = type
        class Rectangle:
            """docstring for Rectangle"""
            def __init__(self):
                self.width = 0
                self.height = 0
            def setSize(self, size):
                """docstring for setSize"""
                self.width, self.height = size
            def getSize(self):
                """docstring for getSize"""
                return self.width, self.height
            size = propery(getSize, setSize)

        r = Rectangle()
        r.width = 10
        r.height = 15
        print r.size()
        r.size((150,100))
        print r.width
            
    property函数实际是拥有很多特殊方法的类,有__get__,__set__,__delete__来定义描述符规则,实现了任何一个方法的对象就叫描述符(descriptor).描述符的特殊之处在于它们是如何被访问的.比如,程序读取一个特性时(尤其是在实例中访问该特性, 但该特性在类中定义时),如果该特性被绑定到实现了__get__方法的对象上,那么就会调用__get__方法(结果值也会返回),这就是属性的绑定方法

    静态方法
        静态方法和类成员方法分辨在创建时分别被加载进Staticmethod类型和Classmethod类型的对象中.  静态方法的定义没有self参数, 且能够被类本身直接调用.  类方法在定义时需要名为cls的类似于self的参数
        ,类成员方法可以直接用类的具体对象调用.但是cls参数是自动被绑定到类的.
            __metaclass__ = type

            class MyClass(object):
                """docstring for ClassName"""
                def smeth():
                    """docstring for smeth"""
                    print 'this is a static method'
                smeth = staticmethod(smeth)

                def cmeth(cls):
                    """docstring for cmeth"""
                    print 'This is a class method of:', cls
                cmeth = classmethod(cmeth)
        在Python2.4中,为手动包装和替换方法引入了装饰器(decorator)的新语法(它能对任何可调用的对象进行包装,既能够用于方法也可能够用于函数),
        使用@操作符,在方法(或函数)的上发将装饰器列出,从而指定一个或者更多的装饰器(多个装饰器在应用时的顺序和指定顺序相反)
            __metaclass__ = type

            class MyClass2:
                """docstring for MyClass2"""
                @staticmethod
                def meth():
                    print 'This is s static method'

                @classmethod
                def cmeth(cls):
                    """docstring for cm"""
                    print 'This is a class method of', cls

            a = MyClass()
            a.smeth()
            a.cmeth()
    其他的魔法方法
        __getattribute__(self,name) 当特性name被访问时会自动调用(只能在新式类中使用)
        __getattr__(self,name) 当特性name被访问且对象没有对应的特性时被自动调用
        __setattr__(self,name,value) 当试图给特性name赋值时会被自动调用
        __delattr__(self,name) 当试图删除特性name时会被自动调用

            class Rectangle:
                """docstring for Rectangle"""
                def __init__(self):
                    self.width = 0
                    self.height = 0
                def __setattr__(self, name, value):
                    if name == 'size':
                        self.width, self.height = value
                    else:
                        self.__dict__[name] = value

                def _getattr__(self, name):
                    if name == 'size':
                        return self.width, self.height
                    else:
                        raise AttributeError

    迭代器iterator,迭代就是重复做一件事很多次.迭代器就是具有next方法(这个方法在调用时不需要任何参数)的对象.
    在调用next方法时,迭代器会返回它的下一个值,如果next方法被调用,但迭代器没有值可以返回,就会引发一个StopIterator异常
    在python3.x,迭代器对象会实现__next__方法而不是next, 而新的内建函数next可以访问这个方法,next(it)等价于2.x版本的it.next()
    __iter__,这个方法是迭代器规则(iterator protocol)的基础
        class Fibs:
            """docstring for Fibc"""
            def __init__(self):
                self.a = 0
                self.b = 1
            def next(self):
                self.a, self.b = self.b, self.a+self.b
                return self.a
            def __iter__(self):
                return self

        fibs = Fibs()
        for f in fibs:
            if f > 1000:
                print 'End Numbers is:',f
                break
            else:
                print f

    内建函数iter可以从可迭代的对象中直接获取迭代器
        >>>it = iter([1,2,3])
        >>>it.next()
        1
        >>>it.next()
        2
    还可以把迭代转成序列,(用list)
        class TestIterator:
            """docstring for Test"""
            value = 0
            def next(self):
                self.value += 1
                if self.value > 10: raise StopIteration
                return self.value
            def __iter__(self):
                return self

        ti = TestIterator()
        a = list(ti)
        print a 
    生成器(简单生成器),是一种用普通的函数语法定义的迭代器.任何包含yield语句的函数就成为生成器
    生成器不会像return那样返回值,而且每次产生多个值. 在yield语句每次产生一个值,函数就会冻结:
    即函数听在那点等待被重新唤醒,函数被重新唤醒后就从停止的那点开始执行
        nested = [[1,2],[3,4],[5,6],[7]]

        def flattern(nested):
            """docstring for flattern"""
            for sublist in nested:
                # code...
                for element in sublist:
                    yield element

        for num in flattern(nested):
            print num

        b = list(flattern(nested))
        print b
    生成器推导式:(生成器表达式)和列表推导式的工作方式类似.可以在当前的圆括号内直接使用.比如在函数调用中.不用增加了另外一对圆括号.
        sum(i**2 for i in range(10))
    递归recursion生成器,注意不要对字符串的对象进行迭代
        def flattern(nested):
            try:
                try: nested + ''
                except: raise TypeError #这里就会忽略掉nest +'' 引发的TypeError.
                for sublist in nested:
                    for element in flattern(sublist):
                        yield element
            except TypeError:
                yield nested
        
        >>>list(flattern([[1,2],3,4,[5,[6,7],[8]]]))
        [1,2,3,4,5,6,7,8]

    生成器是一个包含yield关键字的函数,当它被调用时,在函数体的代码不会被执行.而会返回一个迭代器,每次请求一个值,都会执行生成器中的代码,直到遇到一个yield/return语句,yield语句意味着应该生成一个值.return语句意味着生成器要停止执行(不再生成任何东西,return语句只有在一个生成器中使用时才能进行无参数调用)
        生成器是由两部分组成, 生成器的函数 和生成器的迭代器. 函数用def语句定义,包含yield部分.  迭代器是这个函数的返回部分

    生成器的方法:
        外部作用域访问生成器的send方法.就和next类似.不过需要一个参数(要发送的信息--任意对象)
        内部则刮起生成器,当生成器重新运行的时候,yield方法会返回一个值,也就是外部send方法发送的值,如果next()方法被使用,那么yield方法返回None
            def repeater(value):
                while True:
                new = (yield value)
                if new is not None: value = new
            r = repeater(42)
            r.next() #42
            r.send("Hello, world") #"Hello, world"
    生成器的throw方法:使用异常类型调用, 还有可选的值以及回溯对象, 用于在生成器中引发一个异常
    生成器的close方法:调用时不用参数, 用于停止生成器
    树和图:
        图:是用来直接描述现实问题的数据结构,方便使用算法来计算问题,比如公交线路查询
        树:则是具体的,有b-tree,b+tree,red black tree, 树可以提供查询效率

    

模块
    下列代码会告诉python解释器,除了从默认的Python目录寻找模块之外,还需要从目录/home/python 来查找.
    import sys
    sys.path.append('/home/python/')
    import hello    #一个文件存在/home/python中.就可以在import sys并且指定了目录来直接import.  但是注意,一般导入主要用于定义变量,函数,类等, 只需要定义这些东西一次,导入模块多次和导入一次的效果是一样
    如果想要重新载入模块,可以用内建函数reload(要重新载入的模块).python3.x废弃了reload
        >>>hello = reload(hello)
        Hello, World!
    通过reload函数的返回值会赋给hello,这里就用了重新载入的版本替换了原先的hello版本.
    如果是通过实例化一个模块中的类来创建了一个对象,那么就算重新载入这个模块,不过通过什么方式都无法重新创建该模块的对象的实例.
    该实例依然是旧版本类的实例.如果需要重新载入模块的新类, 就需要重新创建它.
        可以import了模块后,直接调用.
        #hello2.py
        def hello():
            print 'hlow, world!'
        >>>import hello2
        >>>hello2.hello()
        hlow, world!
    为了区分模块是作为程序运行还是导入到其他程序,使用__name__变量
        #hello.py
        def hello2():
            """docstring for he"""
            print 'Hello, World!'
        def test():
            hello2()

        if __name__ == '__main__':test()
        #call
        import sys
        sys.path.append('/home/vc/git/vimrc/doc/python_study_code/')
        import hello

        hello.hello2()

        hello.test()
    模块的正确位置
        这里使用pprint模块中的pprint函数来代替普通的print,可以提供更加智能的打印输出.
        比较好的模块放置位置是系统的dist-packages(win中是site-packages),这个目录就是用来储存模块
            >>> import sys, pprint
            >>> pprint.pprint(sys.path)
            ['',
            '/home/vc/git/vimrc/doc/python_study_code',
             '/usr/bin',
             '/root/lib/python',
             '/usr/lib/python2.7',
             '/usr/lib/python2.7/plat-linux2',
             '/usr/lib/python2.7/lib-tk',
             '/usr/lib/python2.7/lib-old',
             '/usr/lib/python2.7/lib-dynload',
             '/usr/local/lib/python2.7/dist-packages',
             '/usr/lib/python2.7/dist-packages',
             '/usr/lib/python2.7/dist-packages/gst-0.10',
             '/usr/lib/python2.7/dist-packages/gtk-2.0',
             '/usr/lib/pymodules/python2.7']
    PYTHONPATH环境变量
         在.bashrc里面, 加入 export PYTHONPATH=$PYTHONPATH:~/python 这样就会把~/python的路径加到系统的环境变量中, 多个路径以冒号分开.
         win 的,set PYTHONPATH=%PYTHONPATH%;c:\python
    路径配置文件, 用.pth为扩展名的文件,里面有添加到sys.path的目录信息,空行和以#开头的都会被忽略.以import开头的文件会被执行
        需要把该文件放置在可以找到的地方.windows中用sys.prefix定义目录,unix/osx用site-packages目录,
        在windows中,可以用.pyw扩展名.
    包package,为了让Python将其作为包对象,需要包含一个命名为__init__.py的文件(模块),如果将它作为普通模块导入,文件的内容就是包的内容.
        比如一个名为constants的包,文件constants/__init__.py包含语句PI=3.14
            import constants
            print constants.Pi
        drawing包,包含shapes和colors的模块.
            drawing/
            ├── colors.py
            ├── __init__.py
            └── shapes.py
        如果drawing已经在PYTHONPAH. 则可以通过
            import drawing              #imports the drawing package
            import drawing.colors       #imports the colors module
            from drawing import  shapes #imports the sharpes module

    模块中有什么
        import 模块名
        dir(模块名)
        可以看见模块的所有特性(所有函数,类,变量等).一些名字以下划线开始暗示属于内部,可以用列表推导式来过滤掉
            >>>[n for n in dir(模块名) if not n.startswith('_')]

        __all__变量,定义了模块的公有接口(public interface),所以就可以使用from copy import * #*是表示从模块导入的名字代表了什么含义
            >>> copy.__all__
            ['Error', 'copy', 'deepcopy']
        使用__all__可以过滤其他程序不需要或者不想要的变量.如果没有设置__all__,用importo *会默认导入模块中所有不以下划线开头的全局名称

        help函数
        >>>helo(copy.copy)
    官方的文档库http://python.org/doc.lib

python标准库
    sys
        argv        命令行参数,包括脚本名称
                    通过命令行调用python脚本时,可能会在后面加参数,这就是命令行参数(command line argument), 参数之间用空格隔开,这些参数会存在sys.argv列表中,脚本的名字为sys.argv[0]
        exit(flag) 退出当前的程序,可选参数作为给定的返回值或者错误信息.如在try/finally中调用,finally的子句仍然会执行(在unix中,0表示成功)
        modules     映射模块名字到载入模块的字典
        path        是一个字符串列表.包含了要导入的目录名
        pathform    平台,sunos5,win32,linux2
        stdin       标准输入,python利用sys.stdin来获得输入(用于函数的input和raw_input输入),利用sys.stdout来输出
        stdout      标准输出
        stderr      标准错误
    os 
        environ         对环境变量进行映射
        system(command) 对子shell中执行操作系统的命令
        sep             路径中的分隔符(unix /, windows \\, osx :)
        pathsep         分割路径的分隔符,(unix,osx的命令行python用:,windows用;,OSX用::)
        linesep         行分隔符('\n', '\r', '\r\n')
        urandom(n)      返回n字节的加密强随机数据
    fileinput
        input([files[, inplace[, backup]]])  遍历多个输入流中的行
        filename()                           返回当前文件的名称
        lineno()                             返回当前(累计的)行数
        filelineno()                         返回当前文件的行数
        isfirstline()                        检查当前行是否是文件的第一行
        isstdin()                            检查最后一行是否来自sys.stdin
        nextfile()                           关闭当前文件, 移动到下一个文件
        close()                              关闭序列
注意import的时候如果文件名和库名一样,会导致冲突.
    集合set,set类位于sets模块中.
        >>>set(range(10))
        set([0,1,2,3,4,5,6,7,8,9])

